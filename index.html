<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas My Dear</title>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; touch-action: none; }
        
        /* 加载遮罩样式 */
        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s ease-out;
        }
        .loader-content { 
            text-align: center; 
            color: white; 
            font-family: 'Great Vibes', cursive; 
        }
        .snowflake-loader {
            font-size: 3rem;
            margin-bottom: 20px;
            display: inline-block;
            animation: spin 2s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        #loader.fade-out { opacity: 0; pointer-events: none; }

        .ui-overlay { position: absolute; top: 40px; left: 50px; color: white; pointer-events: none; z-index: 10; }
        .title-container h1 { font-family: 'Great Vibes', cursive; font-size: 4.5rem; margin: 0; text-shadow: 0 0 20px rgba(255,255,255,0.4); }
        .hint { position: absolute; bottom: 20px; width: 100%; text-align: center; color: rgba(255,255,255,0.2); font-family: sans-serif; font-size: 11px; letter-spacing: 2px; }
    </style>
</head>
<body>

    <div id="loader">
        <div class="loader-content">
            <div class="snowflake-loader">❄</div>
            <p style="letter-spacing: 3px; font-size: 1.2rem;">正在加载圣诞梦境...</p>
        </div>
    </div>

    <div class="ui-overlay">
        <div class="title-container"><h1>Merry Christmas</h1></div>
    </div>
    <div class="hint">DRAG TO ROTATE • SCROLL TO ZOOM</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls, mainGroup;
        let treeParticles, starParticles, snowParticles, floorParticles, giftGroup, decoLights;
        let revealProgress = 0;
        let isLoaded = false;
        
        const TREE_HEIGHT = 48; 
        const starCount = 18000; 
        const lightCount = 2800; 
        const FLOOR_COUNT = 120000; 
        const SNOW_COUNT = 4000;

        function getDotTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.3, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 50, 260);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 110); 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            const dotTexture = getDotTexture();
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 15, 0);

            mainGroup = new THREE.Group();
            mainGroup.position.y = -22; 
            scene.add(mainGroup);

            // 1. 树顶星
            const starGeo = new THREE.BufferGeometry();
            const starPos = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount; i++) {
                const p = 5; const step = (Math.PI * 2) / (p * 2);
                const angle = Math.random() * Math.PI * 2;
                const mod = angle % (step * 2);
                const innerR = 0.7; const outerR = 4.2; 
                const targetR = mod < step ? innerR + (outerR - innerR) * (mod / step) : outerR - (outerR - innerR) * ((mod - step) / step);
                const r = Math.sqrt(Math.random()) * targetR;
                const finalAngle = angle - (Math.PI / 2);
                starPos[i * 3] = Math.cos(finalAngle) * r;
                starPos[i * 3 + 1] = Math.sin(finalAngle) * r + TREE_HEIGHT + 3; 
                starPos[i * 3 + 2] = (Math.random() - 0.5) * 1.0;
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
            starParticles = new THREE.Points(starGeo, new THREE.PointsMaterial({ size: 0.35, color: 0xFFD41D, transparent: true, opacity: 0, map: dotTexture, blending: THREE.AdditiveBlending, depthWrite: false }));
            mainGroup.add(starParticles);

            // 2. 圣诞树
            const treeCount = 150000;
            const treeGeo = new THREE.BufferGeometry();
            const treePos = new Float32Array(treeCount * 3);
            const treeCols = new Float32Array(treeCount * 3);
            for (let i = 0; i < treeCount; i++) {
                const h = Math.random() * TREE_HEIGHT;
                const r = (TREE_HEIGHT - h) * 0.42; 
                const angle = Math.random() * Math.PI * 2;
                treePos[i * 3] = Math.cos(angle) * r; treePos[i * 3 + 1] = h; treePos[i * 3 + 2] = Math.sin(angle) * r;
                let c = new THREE.Color(Math.floor(h * 3) % 2 === 0 ? 0xB8DB80 : 0x008800);
                treeCols[i * 3] = c.r; treeCols[i * 3 + 1] = c.g; treeCols[i * 3 + 2] = c.b;
            }
            treeGeo.setAttribute('position', new THREE.BufferAttribute(treePos, 3));
            treeGeo.setAttribute('color', new THREE.BufferAttribute(treeCols, 3));
            treeParticles = new THREE.Points(treeGeo, new THREE.PointsMaterial({ size: 0.3, vertexColors: true, transparent: true, opacity: 0, map: dotTexture, alphaTest: 0.1 }));
            mainGroup.add(treeParticles);

            // 3. 圣诞彩灯
            const lightGeo = new THREE.BufferGeometry();
            const lightPos = new Float32Array(lightCount * 3);
            const lightCols = new Float32Array(lightCount * 3);
            const palette = [0xFF3333, 0xFFD700, 0xFFFFFF, 0x00FFFF, 0xFF00FF, 0xFFA500];
            for (let i = 0; i < lightCount; i++) {
                const h = Math.random() * (TREE_HEIGHT - 1) + 0.5;
                const r = (TREE_HEIGHT - h) * 0.42 + 0.45;
                const angle = Math.random() * Math.PI * 2;
                lightPos[i * 3] = Math.cos(angle) * r; lightPos[i * 3 + 1] = h; lightPos[i * 3 + 2] = Math.sin(angle) * r;
                const c = new THREE.Color(palette[Math.floor(Math.random() * palette.length)]);
                lightCols[i * 3] = c.r; lightCols[i * 3 + 1] = c.g; lightCols[i * 3 + 2] = c.b;
            }
            lightGeo.setAttribute('position', new THREE.BufferAttribute(lightPos, 3));
            lightGeo.setAttribute('color', new THREE.BufferAttribute(lightCols, 3));
            decoLights = new THREE.Points(lightGeo, new THREE.PointsMaterial({ size: 1.3, vertexColors: true, transparent: true, opacity: 0, map: dotTexture, blending: THREE.AdditiveBlending }));
            mainGroup.add(decoLights);

            // 4. 圣诞老人与驯鹿
            const santaSquad = new THREE.Group();
            santaSquad.position.set(-45, 45, -20);
            santaSquad.rotation.y = Math.PI * 0.25;
            mainGroup.add(santaSquad);

            function createPointsPart(points, color, size = 0.5) {
                return new THREE.Points(
                    new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(new Float32Array(points), 3)),
                    new THREE.PointsMaterial({ size, color, map: dotTexture, transparent: true, blending: THREE.AdditiveBlending })
                );
            }
            const sledPoints = [];
            for (let t = -2; t <= 2; t += 0.1) {
                sledPoints.push(t*2, (t*t)*0.5, -2); sledPoints.push(t*2, (t*t)*0.5, 2);
                if (t > 1.5) {
                    for (let angle = 0; angle < Math.PI; angle += 0.2) {
                        sledPoints.push(t*2 + Math.sin(angle)*1.5, (t*t)*0.5 + Math.cos(angle)*1.5, -2);
                        sledPoints.push(t*2 + Math.sin(angle)*1.5, (t*t)*0.5 + Math.cos(angle)*1.5, 2);
                    }
                }
            }
            for (let x = -3; x < 1; x += 0.3) {
                for (let z = -1.8; z < 1.8; z += 0.3) sledPoints.push(x, 1.2, z);
                sledPoints.push(x, 1.2 + (x+3)*0.5, -1.8); sledPoints.push(x, 1.2 + (x+3)*0.5, 1.8);
            }
            santaSquad.add(createPointsPart(sledPoints, 0xFF2222, 0.7));

            const drawDeer = (ox, oz) => {
                const p = [];
                for(let i=0; i<40; i++) p.push(ox + Math.random()*3, 1.5 + Math.random()*1.2, oz + (Math.random()-0.5)*0.8);
                for(let i=0; i<15; i++) p.push(ox + 3 + Math.random()*0.8, 2 + i*0.1, oz + (Math.random()-0.5)*0.5);
                for(let i=0; i<10; i++) {
                    p.push(ox + 3.5, 3.5 + i*0.2, oz + 0.5 + i*0.1); p.push(ox + 3.5, 3.5 + i*0.2, oz - 0.5 - i*0.1);
                    p.push(ox + 3.5 + i*0.1, 3.8 + i*0.1, oz + 0.5); p.push(ox + 3.5 + i*0.1, 3.8 + i*0.1, oz - 0.5);
                }
                for(let i=0; i<10; i++) {
                    let y = i * 0.2;
                    p.push(ox+0.5, y, oz-0.3); p.push(ox+0.5, y, oz+0.3);
                    p.push(ox+2.5, y, oz-0.3); p.push(ox+2.5, y, oz+0.3);
                }
                return p;
            };
            santaSquad.add(createPointsPart([...drawDeer(8, -1.5), ...drawDeer(8, 1.5), ...drawDeer(16, -1.5), ...drawDeer(16, 1.5)], 0xD2B48C, 0.6));
            
            const santaMan = [];
            for(let i=0; i<50; i++) santaMan.push(-1.5 + Math.random(), 1.5 + Math.random()*2, (Math.random()-0.5)*1.2);
            santaSquad.add(createPointsPart(santaMan, 0xFFFFFF, 0.8));

            // 5. 实体礼盒组
            giftGroup = new THREE.Group();
            mainGroup.add(giftGroup);
            const boxColors = [0xFF0000, 0x007FFF, 0x00A86B, 0x9B59B6, 0xF39C12];

            function createSolidGift(x, z, size, boxColorHex) {
                const density = 40; 
                const totalPoints = density * density * 6;
                const pos = new Float32Array(totalPoints * 3);
                const cols = new Float32Array(totalPoints * 3);
                const boxColor = new THREE.Color(boxColorHex);
                const ribbonColor = new THREE.Color(0xFFFFFF);
                let pIdx = 0; const half = size / 2;

                function addFace(constant, axis) {
                    for(let i=0; i<density; i++) {
                        for(let j=0; j<density; j++) {
                            const u = (i/(density-1)-0.5)*size;
                            const v = (j/(density-1)-0.5)*size;
                            let px, py, pz;
                            if(axis === 'x'){ px=constant; py=u+half; pz=v; }
                            else if(axis === 'y'){ px=u; py=constant; pz=v; }
                            else { px=u; py=v+half; pz=constant; }
                            pos[pIdx*3]=px; pos[pIdx*3+1]=py; pos[pIdx*3+2]=pz;
                            const isRib = (Math.abs(px)<size*0.16) || (Math.abs(pz)<size*0.16);
                            const c = isRib ? ribbonColor : boxColor;
                            cols[pIdx*3]=c.r; cols[pIdx*3+1]=c.g; cols[pIdx*3+2]=c.b; pIdx++;
                        }
                    }
                }
                addFace(half,'x'); addFace(-half,'x'); addFace(size,'y'); addFace(0,'y'); addFace(half,'z'); addFace(-half,'z');

                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                geo.setAttribute('color', new THREE.BufferAttribute(cols, 3));
                const p = new THREE.Points(geo, new THREE.PointsMaterial({ 
                    size: 0.25, vertexColors: true, transparent: true, opacity: 0, 
                    map: dotTexture, alphaTest: 0.1, depthWrite: true 
                }));
                p.position.set(x, 0, z); p.rotation.y = Math.random()*Math.PI;
                giftGroup.add(p);
            }
            for(let r=0; r<4; r++) {
                const num = 10 + r*7; const rad = 10 + r*8.5;
                for(let i = 0; i < num; i++) {
                    const ang = (i/num)*Math.PI*2 + r;
                    createSolidGift(Math.cos(ang)*rad, Math.sin(ang)*rad, 3.5+Math.random()*3.5, boxColors[(i+r)%boxColors.length]);
                }
            }

            // 6. 雪地
            const floorGeo = new THREE.BufferGeometry();
            const floorPos = new Float32Array(FLOOR_COUNT * 3);
            const floorOriginalX = new Float32Array(FLOOR_COUNT);
            const floorOriginalZ = new Float32Array(FLOOR_COUNT);
            const floorVerticalJitter = new Float32Array(FLOOR_COUNT); 
            const floorSpread = 320; 
            for (let i = 0; i < FLOOR_COUNT; i++) {
                const x = (Math.random() - 0.5) * floorSpread;
                const z = (Math.random() - 0.5) * floorSpread;
                floorOriginalX[i] = x; floorOriginalZ[i] = z;
                floorVerticalJitter[i] = Math.random() * 3.0; 
                floorPos[i * 3] = x; floorPos[i * 3 + 1] = 0; floorPos[i * 3 + 2] = z;
            }
            floorGeo.setAttribute('position', new THREE.BufferAttribute(floorPos, 3));
            floorParticles = new THREE.Points(floorGeo, new THREE.PointsMaterial({ size: 0.6, color: 0xFFFFFF, transparent: true, opacity: 0, map: dotTexture, depthWrite: false }));
            floorParticles.userData = { originalX: floorOriginalX, originalZ: floorOriginalZ, vJitter: floorVerticalJitter, spread: floorSpread };
            scene.add(floorParticles);

            // 7. 雪花
            const snowGeo = new THREE.BufferGeometry();
            const snowPos = new Float32Array(SNOW_COUNT * 3);
            for (let i = 0; i < SNOW_COUNT * 3; i++) snowPos[i] = (Math.random() - 0.5) * 400;
            snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
            snowParticles = new THREE.Points(snowGeo, new THREE.PointsMaterial({ size: 0.5, color: 0xFFFFFF, transparent: true, opacity: 0.7, map: dotTexture }));
            scene.add(snowParticles);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // 初始化完成后关闭加载层并开始淡入
            setTimeout(() => {
                const loader = document.getElementById('loader');
                loader.classList.add('fade-out');
                isLoaded = true;
            }, 1000);
        }

        function animate() {
            requestAnimationFrame(animate);
            if(controls) controls.update();
            const time = Date.now() * 0.001;

            // 加载完成后开始淡入
            if (isLoaded && revealProgress < 1) {
                revealProgress += 0.005;
                if(treeParticles) treeParticles.material.opacity = revealProgress;
                if(starParticles) starParticles.material.opacity = revealProgress;
                if(floorParticles) floorParticles.material.opacity = revealProgress * 0.95;
                if(decoLights) decoLights.material.opacity = revealProgress;
                if(giftGroup) giftGroup.children.forEach(g => g.material.opacity = revealProgress);
            }
            
            if(decoLights) decoLights.material.size = 1.1 + Math.sin(time * 2.5) * 0.5;

            if(floorParticles) {
                const fPos = floorParticles.geometry.attributes.position.array;
                const { originalX, originalZ, vJitter, spread } = floorParticles.userData;
                const halfSpread = spread / 2;
                for (let i = 0; i < FLOOR_COUNT; i++) {
                    let x = originalX[i] + camera.position.x;
                    let z = originalZ[i] + camera.position.z;
                    x = ((x + halfSpread) % spread + spread) % spread - halfSpread;
                    z = ((z + halfSpread) % spread + spread) % spread - halfSpread;
                    fPos[i * 3] = x; 
                    fPos[i * 3 + 1] = -22.5 + Math.sin(x * 0.04) * Math.cos(z * 0.04) * 4.0 + vJitter[i]; 
                    fPos[i * 3 + 2] = z;
                }
                floorParticles.geometry.attributes.position.needsUpdate = true;
            }

            if(snowParticles) {
                const p = snowParticles.geometry.attributes.position.array;
                for (let i = 0; i < SNOW_COUNT; i++) {
                    p[i * 3 + 1] -= 0.22;
                    if (p[i * 3 + 1] < -40) p[i * 3 + 1] = 140;
                }
                snowParticles.geometry.attributes.position.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>